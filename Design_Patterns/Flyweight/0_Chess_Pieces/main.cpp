// Disclaimer: This file is entirely
// Generated by OpenAI's ChatGPT-4, February 2025

#include <iostream>
#include <unordered_map>
#include <string>

// Flyweight class
class ChessPiece {
public:
    virtual void display() = 0;
    virtual std::string getType() = 0;
    virtual std::string getColor() = 0;
};

// Concrete Flyweight classes for different pieces
class Pawn : public ChessPiece {
public:
    Pawn(std::string color) : color(color) {}

    void display() override {
        std::cout << "Pawn " << color << std::endl;
    }

    std::string getType() override {
        return "Pawn";
    }

    std::string getColor() override {
        return color;
    }

private:
    std::string color;
};

class Rook : public ChessPiece {
public:
    Rook(std::string color) : color(color) {}

    void display() override {
        std::cout << "Rook " << color << std::endl;
    }

    std::string getType() override {
        return "Rook";
    }

    std::string getColor() override {
        return color;
    }

private:
    std::string color;
};

class Knight : public ChessPiece {
public:
    Knight(std::string color) : color(color) {}

    void display() override {
        std::cout << "Knight " << color << std::endl;
    }

    std::string getType() override {
        return "Knight";
    }

    std::string getColor() override {
        return color;
    }

private:
    std::string color;
};

// Flyweight Factory class
class ChessPieceFactory {
public:
    ChessPiece* getChessPiece(std::string type, std::string color) {
        // Create a key based on type and color to handle all types of pieces
        std::string key = type + "-" + color;

        // Check if the flyweight already exists, if not, create a new one
        if (pieces.find(key) == pieces.end()) {
            if (type == "Pawn") {
                pieces[key] = new Pawn(color);
            } else if (type == "Rook") {
                pieces[key] = new Rook(color);
            } else if (type == "Knight") {
                pieces[key] = new Knight(color);
            }
        }
        return pieces[key];
    }

private:
    std::unordered_map<std::string, ChessPiece*> pieces;  // Store shared pieces
};

// Context class (has extrinsic state)
class ChessBoard {
public:
    ChessBoard(ChessPieceFactory* factory) : factory(factory) {}

    void placePiece(int row, int col, std::string type, std::string color) {
        ChessPiece* piece = factory->getChessPiece(type, color);
        std::cout << "Placing " << color << " " << piece->getType() 
                  << " at (" << row << ", " << col << ")\n";
        piece->display();  // Displays piece type and color
    }

private:
    ChessPieceFactory* factory;
};

int main() {
    ChessPieceFactory* factory = new ChessPieceFactory();
    ChessBoard board(factory);

    // Place various pieces on the board
    board.placePiece(1, 1, "Pawn", "White");
    board.placePiece(1, 2, "Knight", "Black");
    board.placePiece(2, 1, "Rook", "White");
    board.placePiece(2, 2, "Pawn", "Black");
    board.placePiece(3, 1, "Knight", "White");
    board.placePiece(4, 2, "Rook", "Black");

    // Pieces are reused from the flyweight pool as needed
    return 0;
}
