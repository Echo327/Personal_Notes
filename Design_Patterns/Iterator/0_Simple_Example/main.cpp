// Disclaimer: This file is entirely
// Generated by OpenAI's ChatGPT-4, February 2025

#include <iostream>
#include <vector>

// Iterator Interface
template <typename T>
class Iterator {
public:
    virtual T next() = 0;
    virtual bool hasNext() = 0;
};

// Concrete Iterator
template <typename T>
class ConcreteIterator : public Iterator<T> {
private:
    std::vector<T>& collection;
    size_t index;

public:
    ConcreteIterator(std::vector<T>& collection) : collection(collection), index(0) {}

    T next() override {
        if (hasNext()) {
            return collection[index++];
        }
        throw std::out_of_range("No more elements in the collection.");
    }

    bool hasNext() override {
        return index < collection.size();
    }
};

// Aggregate Interface
template <typename T>
class Aggregate {
public:
    virtual Iterator<T>* createIterator() = 0;
};

// Concrete Aggregate
template <typename T>
class ConcreteAggregate : public Aggregate<T> {
private:
    std::vector<T> items;

public:
    void add(const T& item) {
        items.push_back(item);
    }

    Iterator<T>* createIterator() override {
        return new ConcreteIterator<T>(items);
    }
};

// Client Code
int main() {
    // Create a concrete aggregate
    ConcreteAggregate<std::string> aggregate;
    aggregate.add("Item 1");
    aggregate.add("Item 2");
    aggregate.add("Item 3");

    // Create an iterator for the aggregate
    Iterator<std::string>* iterator = aggregate.createIterator();

    // Iterate over the collection
    while (iterator->hasNext()) {
        std::cout << iterator->next() << std::endl;
    }

    // Clean up
    delete iterator;

    return 0;
}
